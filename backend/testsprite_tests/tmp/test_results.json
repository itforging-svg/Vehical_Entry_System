[
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "fbc6715e-1f3b-4b24-b4b9-e15afa7c71f2",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC001-user signin with valid credentials",
    "description": "Test the /api/auth/signin endpoint to verify that users can successfully log in with valid username and password, and receive a JWT token with correct role assignment.",
    "code": "import requests\n\ndef test_user_signin_with_valid_credentials():\n    base_url = \"http://127.0.0.1:5001\"\n    signin_endpoint = f\"{base_url}/api/auth/signin\"\n    payload = {\n        \"identifier\": \"testUser\",\n        \"password\": \"testPassword123\"\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        response = requests.post(signin_endpoint, json=payload, headers=headers, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n\n    try:\n        response_json = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Assert JWT token presence\n    token = response_json.get(\"accessToken\") or response_json.get(\"token\") or response_json.get(\"jwt\")\n    assert token and isinstance(token, str) and len(token) > 0, \"JWT token not found in response\"\n\n    # Assert role assignment presence and validity\n    role = response_json.get(\"role\") or response_json.get(\"roles\")\n    assert role, \"Role not found in response\"\n    if isinstance(role, list):\n        assert all(isinstance(r, str) and r for r in role), \"Role list contains invalid entries\"\n    else:\n        assert isinstance(role, str) and role, \"Role is not valid string\"\n\ntest_user_signin_with_valid_credentials()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:44.977Z",
    "modified": "2026-01-23T09:04:24.208Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "1ee0a04e-b7f0-4bce-b16b-9e340d1b2532",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC002-create vehicle entry log with complete details",
    "description": "Test the /api/entry/ POST endpoint to ensure a vehicle entry log can be created with all required vehicle and driver details, and the entry timestamp is recorded accurately.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://127.0.0.1:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/signin\"\nENTRY_URL = f\"{BASE_URL}/api/entry/\"\nTIMEOUT = 30\n\n\ndef test_create_vehicle_entry_log_with_complete_details():\n    # Login to get JWT token\n    login_payload = {\n        \"username\": \"testUser\",\n        \"password\": \"testPassword123\"\n    }\n    try:\n        login_resp = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n    login_json = login_resp.json()\n    token = login_json.get(\"accessToken\") or login_json.get(\"token\")\n    assert token, \"Login response did not contain access token\"\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Prepare complete vehicle entry log data\n    today_str = datetime.date.today().isoformat()\n    vehicle_entry_data = {\n        \"plant\": \"Plant A\",\n        \"vehicle_reg\": \"AB123CD\",\n        \"driver_name\": \"John Doe\",\n        \"license_no\": \"DL1234567890\",\n        \"vehicle_type\": \"Truck\",\n        \"puc_validity\": today_str,\n        \"insurance_validity\": today_str,\n        \"chassis_last_5\": \"ABCDE\",\n        \"engine_last_5\": \"12345\",\n        \"purpose\": \"Delivery\",\n        \"material_details\": \"Electronic goods\",\n        \"transporter\": \"XYZ Transports\",\n        \"aadhar_no\": \"123412341234\",\n        \"driver_mobile\": \"9876543210\",\n        \"challan_no\": \"CH123456\",\n        \"security_person_name\": \"Security Guard 1\",\n        \"photos\": [\"base64stringphoto1\", \"base64stringphoto2\"]\n    }\n\n    entry_id = None\n    try:\n        # Create vehicle entry log\n        try:\n            response = requests.post(ENTRY_URL, json=vehicle_entry_data, headers=headers, timeout=TIMEOUT)\n        except requests.RequestException as e:\n            assert False, f\"Create vehicle entry request failed: {e}\"\n\n        assert response.status_code == 201, f\"Expected 201 Created but got {response.status_code}\"\n        resp_json = response.json()\n        # Assuming the response contains an 'id' field for the created entry\n        entry_id = resp_json.get(\"id\")\n        assert entry_id is not None, \"Response JSON does not contain entry log id\"\n\n        # Validate that the returned data matches input where applicable\n        for key in vehicle_entry_data:\n            # photos might be stored differently so we skip deep check on photos\n            if key == \"photos\":\n                continue\n            assert key in resp_json, f\"Response missing field: {key}\"\n            # For date fields, check if valid date string but do not assert exact equality due to server timezone handling\n            if key in [\"puc_validity\", \"insurance_validity\"]:\n                try:\n                    datetime.date.fromisoformat(resp_json[key][:10])\n                except Exception:\n                    assert False, f\"Response {key} is not a valid date string: {resp_json[key]}\"\n            else:\n                assert resp_json[key] == vehicle_entry_data[key], f\"Mismatch for field {key}: expected '{vehicle_entry_data[key]}', got '{resp_json[key]}'\"\n\n        # Validate that entry timestamp is recorded and is a valid ISO datetime string\n        entry_timestamp = resp_json.get(\"entry_timestamp\") or resp_json.get(\"createdAt\") or resp_json.get(\"timestamp\")\n        assert entry_timestamp is not None, \"Entry timestamp not found in response\"\n\n        # Check if entry_timestamp is a valid ISO format datetime string\n        try:\n            datetime.datetime.fromisoformat(entry_timestamp.replace(\"Z\", \"+00:00\"))\n        except Exception:\n            assert False, f\"Entry timestamp is not a valid ISO 8601 datetime: {entry_timestamp}\"\n\n    finally:\n        # Cleanup: delete the created entry log if possible to keep test idempotent\n        if entry_id:\n            delete_url = f\"{ENTRY_URL}{entry_id}\"\n            try:\n                requests.delete(delete_url, headers=headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n\n\ntest_create_vehicle_entry_log_with_complete_details()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 98, in <module>\n  File \"<string>\", line 80, in test_create_vehicle_entry_log_with_complete_details\nAssertionError: Entry timestamp not found in response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:44.984Z",
    "modified": "2026-01-23T09:05:59.857Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "859c425d-255a-4811-8db2-c9e921345935",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC003-register vehicle exit and calculate duration",
    "description": "Test the /api/entry/{id}/exit PUT endpoint to verify that marking a vehicle exit updates the exit timestamp and correctly calculates the total duration of the vehicle's stay.",
    "code": "import requests\nimport datetime\nimport time\n\nBASE_URL = \"http://127.0.0.1:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/signin\"\nENTRY_URL = f\"{BASE_URL}/api/entry/\"\n\nUSERNAME = \"testUser\"\nPASSWORD = \"testPassword123\"\nTIMEOUT = 30\n\n\ndef test_register_vehicle_exit_and_calculate_duration():\n    # Authenticate and get token\n    try:\n        login_resp = requests.post(\n            LOGIN_URL,\n            json={\"username\": USERNAME, \"password\": PASSWORD},\n            timeout=TIMEOUT,\n            verify=False,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        token = login_resp.json().get(\"accessToken\") or login_resp.json().get(\"token\")\n        assert token, \"No JWT token returned on login\"\n    except Exception as e:\n        assert False, f\"Authentication failed due to exception: {e}\"\n\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # Create a new vehicle entry to get an ID\n    entry_payload = {\n        \"plant\": \"TestPlant\",\n        \"vehicle_reg\": \"TEST1234\",\n        \"driver_name\": \"Test Driver\",\n        \"license_no\": \"LIC123456\",\n        \"vehicle_type\": \"Car\",\n        \"puc_validity\": (datetime.date.today() + datetime.timedelta(days=365)).isoformat(),\n        \"insurance_validity\": (datetime.date.today() + datetime.timedelta(days=365)).isoformat(),\n        \"chassis_last_5\": \"ABCDE\",\n        \"engine_last_5\": \"12345\",\n        \"purpose\": \"Testing exit timestamp\",\n        \"material_details\": \"None\",\n        \"transporter\": \"TestTransport\",\n        \"aadhar_no\": \"123456789012\",\n        \"driver_mobile\": \"9999999999\",\n        \"challan_no\": \"CHL123\",\n        \"security_person_name\": \"Security Guard 1\",\n        \"photos\": []\n    }\n\n    entry_id = None\n    try:\n        create_resp = requests.post(\n            ENTRY_URL,\n            json=entry_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n            verify=False,\n        )\n        assert create_resp.status_code == 201, f\"Entry creation failed: {create_resp.text}\"\n        created_entry = create_resp.json()\n        # The created entry ID might be returned in different formats, try common property names\n        entry_id = created_entry.get(\"id\") or created_entry.get(\"entry_id\") or created_entry.get(\"data\", {}).get(\"id\")\n        if not entry_id:\n            # fallback: try to get first int field in response\n            for v in created_entry.values():\n                if isinstance(v, int):\n                    entry_id = v\n                    break\n        assert entry_id is not None, \"Created entry ID not returned\"\n\n        # Wait a short time to create a measurable duration difference\n        time.sleep(2)\n\n        # Register vehicle exit using PUT on /api/entry/{id}/exit\n        exit_resp = requests.put(\n            f\"{ENTRY_URL}{entry_id}/exit\",\n            headers=headers,\n            timeout=TIMEOUT,\n            verify=False,\n        )\n        assert exit_resp.status_code == 200, f\"Exit registration failed: {exit_resp.text}\"\n        exit_data = exit_resp.json()\n\n        # Validate exit timestamp and duration fields\n        # Duration might be under 'duration' or 'total_duration', consider nested 'data' field\n        possible_duration_keys = ['duration', 'total_duration']\n        exit_timestamp = exit_data.get(\"exit_time\") or exit_data.get(\"exitDateTime\") or exit_data.get(\"data\", {}).get(\"exit_time\")\n        duration = None\n        for key in possible_duration_keys:\n            duration = exit_data.get(key) or exit_data.get(\"data\", {}).get(key)\n            if duration is not None:\n                break\n\n        assert exit_timestamp, \"Exit timestamp (exit_time) not found in response\"\n\n        # parse exit timestamp ISO8601 string if possible\n        try:\n            exit_dt = datetime.datetime.fromisoformat(exit_timestamp.replace(\"Z\", \"+00:00\"))\n        except Exception:\n            exit_dt = None\n        assert exit_dt is not None, \"Exit timestamp is not a valid ISO datetime\"\n\n        # Check duration is positive number or valid string indicating duration\n        assert duration is not None, \"Duration not found in response\"\n        if isinstance(duration, (int, float)):\n            assert duration > 0, \"Duration must be positive\"\n        elif isinstance(duration, str):\n            assert len(duration) > 0, \"Duration string must not be empty\"\n        else:\n            assert False, f\"Duration has unexpected type: {type(duration)}\"\n\n    finally:\n        # Cleanup: delete the created entry if ID exists\n        if entry_id is not None:\n            try:\n                requests.delete(f\"{ENTRY_URL}{entry_id}\", headers=headers, timeout=TIMEOUT, verify=False)\n            except Exception:\n                pass  # best effort cleanup\n\n\ntest_register_vehicle_exit_and_calculate_duration()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 123, in <module>\n  File \"<string>\", line 106, in test_register_vehicle_exit_and_calculate_duration\nAssertionError: Duration not found in response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:44.990Z",
    "modified": "2026-01-23T09:06:09.705Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "82963920-0778-4ef6-a218-aa404052c550",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC004-approve vehicle entry log",
    "description": "Test the /api/entry/{id}/approve PUT endpoint to confirm that an administrator or authorized user can approve a vehicle entry log successfully.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://127.0.0.1:5001\"\nLOGIN_ENDPOINT = \"/api/auth/signin\"\nENTRY_ENDPOINT = \"/api/entry/\"\nAPPROVE_ENDPOINT_TEMPLATE = \"/api/entry/{id}/approve\"\nTIMEOUT = 30\n\nUSERNAME = \"testUser\"\nPASSWORD = \"testPassword123\"\n\n\ndef test_approve_vehicle_entry_log():\n    session = requests.Session()\n\n    # Login to get JWT token\n    login_payload = {\"identifier\": USERNAME, \"password\": PASSWORD}\n    try:\n        login_resp = session.post(\n            BASE_URL + LOGIN_ENDPOINT,\n            json=login_payload,\n            timeout=TIMEOUT,\n            verify=False,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        jwt_token = login_resp.json().get(\"accessToken\") or login_resp.json().get(\"token\")\n        assert jwt_token, \"No JWT token received\"\n\n        headers = {\"Authorization\": f\"Bearer {jwt_token}\"}\n\n        # Create a new vehicle entry log to approve\n        today = datetime.date.today()\n        entry_payload = {\n            \"plant\": \"plant1\",\n            \"vehicle_reg\": \"TEST1234\",\n            \"driver_name\": \"John Doe\",\n            \"license_no\": \"LIC123456\",\n            \"vehicle_type\": \"Truck\",\n            \"puc_validity\": today.isoformat(),\n            \"insurance_validity\": today.isoformat(),\n            \"chassis_last_5\": \"ABCDE\",\n            \"engine_last_5\": \"12345\",\n            \"purpose\": \"Delivery\",\n            \"material_details\": \"Electronics\",\n            \"transporter\": \"Transport Co\",\n            \"aadhar_no\": \"123412341234\",\n            \"driver_mobile\": \"9876543210\",\n            \"challan_no\": \"CH123456\",\n            \"security_person_name\": \"Security Guard 1\",\n            \"photos\": [],\n        }\n\n        create_resp = session.post(\n            BASE_URL + ENTRY_ENDPOINT,\n            json=entry_payload,\n            headers=headers,\n            timeout=TIMEOUT,\n            verify=False,\n        )\n        assert create_resp.status_code == 201, f\"Create entry failed: {create_resp.text}\"\n        created_entry = create_resp.json()\n        entry_id = created_entry.get(\"id\")\n        if entry_id is None:\n            # Sometimes id could be directly returned or under data/entry keys\n            # Fallback: try to get id from response body keys if not direct\n            if isinstance(created_entry, dict):\n                for key in [\"id\", \"_id\"]:\n                    if key in created_entry:\n                        entry_id = created_entry[key]\n                        break\n            assert entry_id is not None, \"Created entry ID not found in response\"\n\n        try:\n            # Approve the vehicle entry log\n            approve_resp = session.put(\n                BASE_URL + APPROVE_ENDPOINT_TEMPLATE.format(id=entry_id),\n                headers=headers,\n                timeout=TIMEOUT,\n                verify=False,\n            )\n            assert approve_resp.status_code == 200, f\"Approve failed: {approve_resp.text}\"\n\n            # Optionally verify the response content if any\n            approve_json = approve_resp.json()\n            # Could check for some success flag or approved status if present\n            # But minimal: just check response code 200 as per PRD\n\n        finally:\n            # Cleanup: delete the created vehicle entry log to keep DB clean\n            # No explicit DELETE endpoint in PRD, so if not available, skip\n            # This PRD does not specify a delete API, hence skipping cleanup step\n\n            pass\n\n    finally:\n        session.close()\n\n\ntest_approve_vehicle_entry_log()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:44.995Z",
    "modified": "2026-01-23T09:04:36.608Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "2a8b44d7-7533-4b9a-b189-b7704146c51a",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC005-reject vehicle entry log with reason",
    "description": "Test the /api/entry/{id}/reject PUT endpoint to ensure that a vehicle entry log can be rejected with a provided reason, and the rejection is recorded properly.",
    "code": "import requests\nimport datetime\n\nBASE_URL = \"http://127.0.0.1:5001\"\nTIMEOUT = 30\nLOGIN_ENDPOINT = f\"{BASE_URL}/api/auth/signin\"\nENTRY_ENDPOINT = f\"{BASE_URL}/api/entry\"\n\nTEST_USER = {\"identifier\": \"testUser\", \"password\": \"testPassword123\"}\n\n\ndef test_reject_vehicle_entry_log_with_reason():\n    session = requests.Session()\n    # Login to get JWT token\n    try:\n        login_resp = session.post(\n            LOGIN_ENDPOINT,\n            json={\"identifier\": TEST_USER[\"identifier\"], \"password\": TEST_USER[\"password\"]},\n            timeout=TIMEOUT,\n            verify=False,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        token = login_resp.json().get(\"accessToken\") or login_resp.json().get(\"token\")\n        assert token, \"No token received on login\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Create a new vehicle entry log to get an ID to reject\n        entry_payload = {\n            \"plant\": \"PlantA\",\n            \"vehicle_reg\": \"TEST1234\",\n            \"driver_name\": \"John Doe\",\n            \"license_no\": \"LIC123456\",\n            \"vehicle_type\": \"Truck\",\n            \"puc_validity\": datetime.date.today().isoformat(),\n            \"insurance_validity\": datetime.date.today().isoformat(),\n            \"chassis_last_5\": \"ABCDE\",\n            \"engine_last_5\": \"12345\",\n            \"purpose\": \"Delivery\",\n            \"material_details\": \"Construction material\",\n            \"transporter\": \"Trans Co\",\n            \"aadhar_no\": \"123412341234\",\n            \"driver_mobile\": \"9999999999\",\n            \"challan_no\": \"CH123456\",\n            \"security_person_name\": \"Security1\",\n            \"photos\": []\n        }\n\n        create_resp = session.post(ENTRY_ENDPOINT + \"/\", json=entry_payload, timeout=TIMEOUT, headers=headers, verify=False)\n        assert create_resp.status_code == 201, f\"Failed to create entry log: {create_resp.text}\"\n        entry_data = create_resp.json()\n        entry_id = entry_data.get(\"id\") or entry_data.get(\"entry_id\")\n        # If server does not return id in body, try to find it from Location header or error out\n        if entry_id is None:\n            location = create_resp.headers.get(\"Location\")\n            if location and location.rstrip(\"/\").split(\"/\")[-1].isdigit():\n                entry_id = int(location.rstrip(\"/\").split(\"/\")[-1])\n            else:\n                raise AssertionError(\"Entry ID not returned by create entry endpoint\")\n\n        # Reject the vehicle entry log\n        reject_reason = {\"reason\": \"Invalid documentation\"}\n        reject_resp = session.put(f\"{ENTRY_ENDPOINT}/{entry_id}/reject\", json=reject_reason, headers=headers, timeout=TIMEOUT, verify=False)\n        assert reject_resp.status_code == 200, f\"Reject request failed: {reject_resp.text}\"\n\n        # Verify rejection recorded properly - if the API provides a way to fetch entry details\n        # We will try to GET /api/entry/{id} or fallback to today's logs and find this entry\n        entry_detail_resp = session.get(f\"{ENTRY_ENDPOINT}/today\", headers=headers, timeout=TIMEOUT, verify=False)\n        assert entry_detail_resp.status_code == 200, f\"Failed to fetch today's entries: {entry_detail_resp.text}\"\n        entries = entry_detail_resp.json()\n        # Find the entry by ID\n        entry_record = next((e for e in entries if e.get(\"id\") == entry_id), None)\n        assert entry_record is not None, \"Entry record not found after reject\"\n        # Check if rejection reason is recorded\n        # The field name for rejection reason isn't specified explicitly in the PRD, so check few possibilities\n        rejection_fields = [\"reject_reason\", \"reason\", \"rejection_reason\", \"rejectReason\"]\n        found_reason = None\n        for field in rejection_fields:\n            if field in entry_record:\n                found_reason = entry_record[field]\n                break\n        assert found_reason == reject_reason[\"reason\"], f\"Rejection reason not recorded properly. Expected '{reject_reason['reason']}', got '{found_reason}'\"\n    finally:\n        # Cleanup: delete the created entry log to avoid clutter\n        try:\n            if 'entry_id' in locals() or 'entry_id' in globals():\n                del_resp = session.delete(f\"{ENTRY_ENDPOINT}/{entry_id}\", headers=headers, timeout=TIMEOUT, verify=False)\n                # Not all APIs support delete, so do not assert here\n        except Exception:\n            pass\n\n\ntest_reject_vehicle_entry_log_with_reason()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:45.001Z",
    "modified": "2026-01-23T09:04:58.687Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "493738db-2271-45a0-aea7-387da42fffd3",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC006-retrieve vehicle entry history by identifier",
    "description": "Test the /api/entry/history/{identifier} GET endpoint to verify that the system returns the correct historical entry and exit logs for a given vehicle or driver identifier.",
    "code": "import requests\n\nBASE_URL = \"http://127.0.0.1:5001\"\nIDENTIFIER = \"testUser\"\nUSERNAME = \"testUser\"\nPASSWORD = \"testPassword123\"\nTIMEOUT = 30\n\ndef test_retrieve_vehicle_entry_history_by_identifier():\n    session = requests.Session()\n    try:\n        # Login to get JWT token\n        login_url = f\"{BASE_URL}/api/auth/signin\"\n        login_payload = {\"username\": USERNAME, \"password\": PASSWORD}\n        login_response = session.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_response.status_code == 200, f\"Login failed with status {login_response.status_code}\"\n        token = login_response.json().get(\"accessToken\") or login_response.json().get(\"token\")\n        assert token is not None, \"No access token received on login\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n\n        # Retrieve vehicle entry history by identifier\n        history_url = f\"{BASE_URL}/api/entry/history/{IDENTIFIER}\"\n        history_response = session.get(history_url, headers=headers, timeout=TIMEOUT)\n        assert history_response.status_code == 200, f\"History retrieval failed with status {history_response.status_code}\"\n        history_data = history_response.json()\n\n        # The response should be a list or dict containing entry and exit logs\n        assert isinstance(history_data, (list, dict)), \"History response is not a list or dict\"\n        # If it is list, check if entries have the expected keys, else if dict check accordingly\n        if isinstance(history_data, list):\n            for entry in history_data:\n                assert \"vehicle_reg\" in entry or \"driver_name\" in entry, \"Expected key missing in history entry\"\n                assert \"entry_time\" in entry or \"entry_timestamp\" in entry or \"check_in\" in entry, \"Entry time missing in history entry\"\n        elif isinstance(history_data, dict):\n            # Check that dict contains keys indicating history logs\n            keys = history_data.keys()\n            assert any(k in keys for k in [\"history\", \"entries\", \"logs\"]), \"Expected history keys not found in response\"\n\n    finally:\n        session.close()\n\ntest_retrieve_vehicle_entry_history_by_identifier()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 45, in <module>\n  File \"<string>\", line 27, in test_retrieve_vehicle_entry_history_by_identifier\nAssertionError: History retrieval failed with status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:45.007Z",
    "modified": "2026-01-23T09:05:07.028Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "9c2b5f8b-1c34-409e-8378-a9efcd9ec69d",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC007-get todays vehicle entry logs",
    "description": "Test the /api/entry/today GET endpoint to ensure it returns the list of vehicle entry logs created on the current date, accessible only to authorized users.",
    "code": "import requests\n\nBASE_URL = \"http://127.0.0.1:5001\"\nLOGIN_URL = f\"{BASE_URL}/api/auth/signin\"\nTODAY_LOGS_URL = f\"{BASE_URL}/api/entry/today\"\nTIMEOUT = 30\n\ndef test_get_todays_vehicle_entry_logs():\n    # Authenticate user to get JWT token\n    login_payload = {\"identifier\": \"testUser\", \"password\": \"testPassword123\"}\n    try:\n        login_resp = requests.post(LOGIN_URL, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        token = login_data.get(\"accessToken\") or login_data.get(\"token\") or login_data.get(\"jwt\")\n        assert token, \"Token not found in login response\"\n    except requests.RequestException as e:\n        assert False, f\"Login request failed: {e}\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Request today's vehicle entry logs\n    try:\n        resp = requests.get(TODAY_LOGS_URL, headers=headers, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Failed to get today's logs: {resp.text}\"\n        logs = resp.json()\n        assert isinstance(logs, list), \"Response is not a list\"\n        # Additional checks: each log should have date of entry matching today (basic check)\n        # Since no exact format given, just check some keys existence\n        for log in logs:\n            assert isinstance(log, dict), \"Log entry is not a dict\"\n            # Check keys likely present per PRD (vehicle_reg, driver_name, purpose)\n            assert \"vehicle_reg\" in log, \"vehicle_reg missing in log entry\"\n            assert \"driver_name\" in log, \"driver_name missing in log entry\"\n            assert \"purpose\" in log, \"purpose missing in log entry\"\n    except requests.RequestException as e:\n        assert False, f\"Request to today's entry logs failed: {e}\"\n\ntest_get_todays_vehicle_entry_logs()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:45.012Z",
    "modified": "2026-01-23T09:04:45.957Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "94978036-8452-4609-ad0c-f04361d75d6d",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC008-get vehicle entry logs filtered by date",
    "description": "Test the /api/entry/bydate GET endpoint with a date query parameter to verify that the system returns vehicle entry logs filtered correctly by the specified date.",
    "code": "import requests\nfrom datetime import date\nimport urllib3\n\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\n\nBASE_URL = \"http://127.0.0.1:5001\"\nUSERNAME = \"testUser\"\nPASSWORD = \"testPassword123\"\nTIMEOUT = 30\n\n\ndef test_get_vehicle_entry_logs_filtered_by_date():\n    # Login and get JWT token\n    login_url = f\"{BASE_URL}/api/auth/signin\"\n    login_payload = {\"username\": USERNAME, \"password\": PASSWORD}\n    login_headers = {\"Content-Type\": \"application/json\"}\n\n    try:\n        login_response = requests.post(\n            login_url, json=login_payload, headers=login_headers, timeout=TIMEOUT, verify=False\n        )\n        assert login_response.status_code == 200, f\"Login failed: {login_response.text}\"\n        token = login_response.json().get(\"accessToken\") or login_response.json().get(\"token\")\n        assert token, \"No token found in login response\"\n\n        auth_headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Create a vehicle entry log to ensure there is at least one log for the date\n        create_entry_url = f\"{BASE_URL}/api/entry/\"\n        entry_payload = {\n            \"plant\": \"Plant1\",\n            \"vehicle_reg\": \"TEST1234\",\n            \"driver_name\": \"Test Driver\",\n            \"license_no\": \"LIC12345\",\n            \"vehicle_type\": \"Car\",\n            \"puc_validity\": str(date.today()),\n            \"insurance_validity\": str(date.today()),\n            \"chassis_last_5\": \"ABCDE\",\n            \"engine_last_5\": \"12345\",\n            \"purpose\": \"Testing\",\n            \"material_details\": \"None\",\n            \"transporter\": \"Test Transport\",\n            \"aadhar_no\": \"111122223333\",\n            \"driver_mobile\": \"9999999999\",\n            \"challan_no\": \"CH1234\",\n            \"security_person_name\": \"Security Guard\",\n            \"photos\": []\n        }\n\n        create_response = requests.post(\n            create_entry_url, json=entry_payload, headers=auth_headers, timeout=TIMEOUT, verify=False\n        )\n        assert create_response.status_code == 201, f\"Entry creation failed: {create_response.text}\"\n        created_entry = create_response.json()\n        created_id = created_entry.get(\"id\")\n\n        try:\n            # Query the /api/entry/bydate with today's date\n            query_date = str(date.today())\n            get_logs_url = f\"{BASE_URL}/api/entry/bydate\"\n            params = {\"date\": query_date}\n\n            get_logs_response = requests.get(\n                get_logs_url, headers=auth_headers, params=params, timeout=TIMEOUT, verify=False\n            )\n            assert get_logs_response.status_code == 200, f\"Failed to get logs: {get_logs_response.text}\"\n\n            logs = get_logs_response.json()\n            assert isinstance(logs, list), \"Response should be a list of logs\"\n\n            # Check that the created vehicle_reg is present in the logs\n            vehicle_regs = [log.get(\"vehicle_reg\") for log in logs if log.get(\"vehicle_reg\")]\n            assert \"TEST1234\" in vehicle_regs, f\"Created entry with vehicle_reg TEST1234 not found in logs for date {query_date}\"\n\n        finally:\n            # Cleanup: delete the created entry to keep environment clean\n            if created_id:\n                delete_url = f\"{BASE_URL}/api/entry/{created_id}/reject\"\n                # The API does not specify a DELETE endpoint; using reject with reason \"Test cleanup\"\n                reject_payload = {\"reason\": \"Test cleanup\"}\n                reject_response = requests.put(\n                    delete_url, json=reject_payload, headers=auth_headers, timeout=TIMEOUT, verify=False\n                )\n                # Accept both 200 and 204 if it happens\n                assert reject_response.status_code in [200, 204], f\"Cleanup reject failed: {reject_response.text}\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n\ntest_get_vehicle_entry_logs_filtered_by_date()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:45.018Z",
    "modified": "2026-01-23T09:05:50.226Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "dad6b491-e03c-4038-ab5f-6054b6fc5003",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC009-list blacklisted vehicles",
    "description": "Test the /api/blacklist GET endpoint to confirm that authorized users can retrieve the list of all blacklisted vehicles with their reasons.",
    "code": "import requests\n\nBASE_URL = \"http://127.0.0.1:5001\"\nUSERNAME = \"testUser\"\nPASSWORD = \"testPassword123\"\nTIMEOUT = 30\n\n\ndef test_list_blacklisted_vehicles():\n    try:\n        # Login to get JWT token\n        login_url = f\"{BASE_URL}/api/auth/signin\"\n        login_payload = {\n            \"identifier\": USERNAME,\n            \"password\": PASSWORD\n        }\n        login_headers = {\n            \"Content-Type\": \"application/json\"\n        }\n\n        login_resp = requests.post(login_url, json=login_payload, headers=login_headers, timeout=TIMEOUT, verify=False)\n        assert login_resp.status_code == 200, f\"Login failed with status code {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert \"accessToken\" in login_data or \"token\" in login_data, \"No token found in login response\"\n\n        token = login_data.get(\"accessToken\") or login_data.get(\"token\")\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n\n        # GET /api/blacklist to list blacklisted vehicles\n        blacklist_url = f\"{BASE_URL}/api/blacklist\"\n        resp = requests.get(blacklist_url, headers=auth_headers, timeout=TIMEOUT, verify=False)\n        assert resp.status_code == 200, f\"Expected 200 OK but got {resp.status_code}\"\n\n        resp_json = resp.json()\n        # response should be a list (array) of blacklisted vehicles with fields vehicle_no and reason\n        assert isinstance(resp_json, list), \"Response is not a list\"\n\n        for item in resp_json:\n            assert isinstance(item, dict), \"Blacklist item is not an object\"\n            assert \"vehicle_no\" in item, \"Blacklist item missing 'vehicle_no'\"\n            assert \"reason\" in item, \"Blacklist item missing 'reason'\"\n            assert isinstance(item[\"vehicle_no\"], str), \"'vehicle_no' is not a string\"\n            assert isinstance(item[\"reason\"], str), \"'reason' is not a string\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n\ntest_list_blacklisted_vehicles()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:45.023Z",
    "modified": "2026-01-23T09:05:01.992Z"
  },
  {
    "projectId": "e73ccca3-f758-45d6-a109-23af769eba19",
    "testId": "226f0133-3adc-4462-8598-e968aca3e232",
    "userId": "3438a4f8-50c1-70cb-bbd5-66b47ec22ec6",
    "title": "TC010-add vehicle to blacklist with reason",
    "description": "Test the /api/blacklist POST endpoint to ensure that a vehicle can be added to the blacklist with a valid vehicle number and reason, and the entry is stored securely.",
    "code": "import requests\n\nBASE_URL = \"http://127.0.0.1:5001\"\nTIMEOUT = 30\n\ndef test_add_vehicle_to_blacklist_with_reason():\n    session = requests.Session()\n    try:\n        # Authenticate user to get JWT token\n        auth_payload = {\n            \"identifier\": \"testUser\",\n            \"password\": \"testPassword123\"\n        }\n        auth_resp = session.post(\n            f\"{BASE_URL}/api/auth/signin\",\n            json=auth_payload,\n            timeout=TIMEOUT\n        )\n        assert auth_resp.status_code == 200, f\"Authentication failed: {auth_resp.text}\"\n        auth_data = auth_resp.json()\n        token = auth_data.get(\"accessToken\") or auth_data.get(\"token\") or auth_data.get(\"jwt\") or auth_data.get(\"access_token\")\n        assert token, \"No JWT token found in authentication response\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Add vehicle to blacklist with reason\n        blacklist_payload = {\n            \"vehicle_no\": \"TEST-1234\",\n            \"reason\": \"Suspicious activity detected\"\n        }\n        resp = session.post(\n            f\"{BASE_URL}/api/blacklist\",\n            json=blacklist_payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 201, f\"Failed to add vehicle to blacklist: {resp.text}\"\n\n        # Verify the returned data (if any)\n        try:\n            resp_data = resp.json()\n            # If response contains added data, verify fields\n            if isinstance(resp_data, dict):\n                assert resp_data.get(\"vehicle_no\") == \"TEST-1234\", \"Returned vehicle_no mismatch\"\n                assert resp_data.get(\"reason\") == \"Suspicious activity detected\", \"Returned reason mismatch\"\n        except ValueError:\n            # No JSON response, skip validation\n            pass\n\n    finally:\n        # Cleanup: remove the blacklisted vehicle created in test\n        # Try to get blacklist entries to find the new record\n        try:\n            list_resp = session.get(\n                f\"{BASE_URL}/api/blacklist\",\n                headers=headers,\n                timeout=TIMEOUT\n            )\n            if list_resp.status_code == 200:\n                blacklisted = list_resp.json()\n                if isinstance(blacklisted, list):\n                    for entry in blacklisted:\n                        if entry.get(\"vehicle_no\") == \"TEST-1234\":\n                            # Assuming there is a DELETE endpoint or alternative to remove blacklist entry\n                            # As deletion is not documented, skip removal if unavailable\n                            # If DELETE exists, example:\n                            # del_resp = session.delete(f\"{BASE_URL}/api/blacklist/{entry['id']}\", headers=headers, timeout=TIMEOUT)\n                            # assert del_resp.status_code in (200,204)\n                            pass\n        except Exception:\n            pass\n\ntest_add_vehicle_to_blacklist_with_reason()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-23T09:03:45.029Z",
    "modified": "2026-01-23T09:05:07.022Z"
  }
]
